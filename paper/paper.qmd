---
title: "My title"
subtitle: "My subtitle if needed"
author: 
  - Siddharth Gowda
thanks: "Code and data are available at: [https://github.com/siddharthgowda/ipl_wicket_analysis](https://github.com/siddharthgowda/ipl_wicket_analysis)."
date: today
date-format: long
abstract: "First sentence. Second sentence. Third sentence. Fourth sentence."
format: pdf
number-sections: true
bibliography: references.bib
---

```{r}
#| include: false
#| warning: false
#| message: false

library(tidyverse)
library(arrow)
library(here)
library(knitr)
library(modelsummary)
library(marginaleffects)

cleaned_data <- read_parquet(here("data/02-analysis_data/cleaned_data.parquet"))
test_data <- read_parquet(here("data/02-analysis_data/test_data.parquet"))
train_data <- read_parquet(here("data/02-analysis_data/train_data.parquet"))
set.seed(888)
```


# Introduction

\newpage

# Data {#sec-data}

```{r}
#| label: tbl-cleaned-data
#| tbl-cap: All Variables in the Cleaned Data Set 
#| echo: false
#| warning: false

cleaned_data %>% select(!c(year, venue, batter_playing_role, bowler_playing_role, innings, ball, batting_team, bowling_team, wickets_lost_yet, target)) %>% 
  head(1) %>% kable(col.names = c(
    'Match ID', 
    'Over', 
    'Striker', 
    'Bowler', 
    'Runs Off Bat', 
    'Wicket', 
    'Run Rate',
    'Batting Style', 
    'Bowling Style', 
    'Previous Over Wickets'
))

# cleaned_data %>% 
#   head(1) %>% kable(col.names = c(
#     'Match ID', 
#     'Year', 
#     'Venue', 
#     'Innings', 
#     'Over', 
#     'Ball', 
#     'Batting Team', 
#     'Bowling Team', 
#     'Striker', 
#     'Bowler', 
#     'Runs Off Bat', 
#     'Wickets Lost Yet', 
#     'Wicket', 
#     'Target', 
#     'Run Rate', 
#     'Batting Style', 
#     'Batter Playing Role', 
#     'Bowling Style', 
#     'Bowler Playing Role', 
#     'Previous Over Wickets'
# ))

```
@tbl-cleaned-data show all data sample of a row in the cleaned data set. While there technically are more variables in the data set, these are the most important variables in the data set. Information about all variables in the cleaned data set are visible in @sec-cleaned-data-dictionary, including variables not in @tbl-cleaned-data.

## Measurement

All cricket data is from the [@citeR] package [@cricketdata]. The data that was used is from the CRAN version of the package and not the [@github] developer tools version because the CRAN is more stable. [@cricketdata] takes data from [@espncricinfo] and [@cricsheet]. While not stated by [@cricketdata], based on the code the team behind the package are scrapping the HTML of ESPN Cricinfo and Cricsheet, As a result, anyone using the package must respect the rate limits set by these sites. Therefore, the data was first saved as CSV before performing any other cleaning and analysis.

More information about the raw data sets, measurements, [@cricsheet], [@espncricinfo], and [@cricketdata] is in @sec-data-sheet.


## Data Cleaning

In terms of data cleaning, only data from [@ipl] season from 2021 to 2024 (the most recent tournament) is present. This was none to make sure all data analysis about the IPL cricket is up to date, as certain strategies that used to be effective are no longer effective in IPL cricket. Also, two data sets were used IPL men's tournament data from 2021 to 2024 and player meta data (more about this in @sec-data-sheet). The IPL men's data set had play-by-play data for each ball bowled in each game in the IPL season. The two data sets were merged so that striker meta data and bowler meta data were included in each line. This including things like batting style and bowling style. Moreover, certain rows with missing data were removed and the current run rate and number of wickets in the previous over variables were created based variables orginally included in the raw data set. Also, some data rows had clearly incorrect values, like a innings value of 6, when there are only 2 innings in T20 IPL cricket. These rows were removed from analysis.

## Estimand and Response Variable

The estimated for the research paper is likelihood a ball will result in a wicket. The goal of the paper is to understand when wickets occur. The wicket variable is the response variable. 


## Predictor Variables

All other variables besides wicket listed in the begging of @sec-data are predictor variables.

```{r}
#| label: tbl-bowling-style
#| tbl-cap: Fast Bowlers Are More Common Then Spinners
#| echo: false
#| warning: false

num_bowlers_per_type <- cleaned_data %>%
  group_by(bowling_style) %>% 
  summarise(
    num_bowlers = n_distinct(bowler)                            
  )

num_bowlers_per_type %>% kable(col.names = c("Bowling Style", "Number of Bowlers"))

```
Based on @tbl-bowling-style, there are more non-spin bowlers than spin bowlers. Spin bowlers include wrist spin, legbreak, and legbreak googly, and pace bowlesr are fast, medium fast, and medium. Also, there are more right arm bowlers than left arm bowlers.


```{r}
#| label: tbl-batting-style
#| tbl-cap: There are more right hand batsman.
#| echo: false
#| warning: false

num_batters_per_type <- cleaned_data %>%
  group_by(batting_style) %>% 
  summarise(
    num_batters = n_distinct(striker)                          
  )

num_batters_per_type %>% kable(col.names = c("Batting Style", "Number of Batters"))

```
From @tbl-batting-style, way more batsman are right handed than left handed.

## Relationship Between Wickets and other Variables

```{r}
#| label: fig-over-wickets
#| fig-cap: Wickets are more likely later in the innings
#| echo: false
#| warning: false

over_boundaries <- cleaned_data %>%
  group_by(over) %>%
  summarise(
    num_wickets = sum(wicket == TRUE),  
    num_balls = n()
  ) %>% arrange(desc(num_wickets), desc(num_balls))

ggplot(over_boundaries, aes(x = over, y = num_wickets)) +
  geom_point(color = "steelblue", size = 3) +
  geom_smooth(method = "lm") +
  labs(
       x = "Over",
       y = "Number of Wickets") +
  theme_minimal()

```
From @fig-over-wickets, there is a pretty strong linear positive relationship between the over number and the number of wickets that occur. It is important to note that in the last over (over 20) wicket occur way more than other overs. Also over 5 has more wickets that linear trend.

```{r}
#| label: fig-bowlingstyle-wickets
#| fig-cap: Wickets are more likely later in the innings
#| echo: false
#| warning: false

bowling_batting_matchup_boundaries <- cleaned_data %>%
  group_by(bowling_style, batting_style) %>%
  summarise(
    wicket_percentage = sum(wicket == TRUE)/n(),  
    num_balls = n(),                             
  ) %>% arrange(desc(wicket_percentage), desc(num_balls))

ggplot(bowling_batting_matchup_boundaries, aes(x = bowling_style, y = wicket_percentage, fill = batting_style)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  labs(
    x = "Bowling Style",
    y = "Wickets Percentage",
    fill = "Batting Style"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
Based on @fig-bowlingstyle-wickets, for left hand batters, left arm fast bowlers have the highest chance for wickets. For right hand batters, medium pace or medium fast pace bowlers are the most likely to get wickets.

```{r}
#| label: fig-prevoverwickets-wickets
#| fig-cap: Positive Association Between Wickets in the Last and Next Over
#| echo: false
#| warning: false
wickets_prev_over_wickets <- cleaned_data %>%
  group_by(over) %>%
  summarise(
    num_wickets = sum(wicket == TRUE),
    prev_over_wickets = mean(prev_over_wickets),
    num_balls = n(),                             
  ) %>% arrange(desc(num_wickets), desc(num_balls))

ggplot(wickets_prev_over_wickets, aes(x = prev_over_wickets, y = num_wickets)) +
  geom_point(color = "steelblue", size = 3, alpha = 0.7) +
  geom_smooth(method = "lm") +
  labs(
       x = "Average Number of Wickets in Previous Over Wickets",
       y = "Number of Wickets") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
In @fig-prevoverwickets-wickets, there is a strong positive correlation between the average number of wickets in the previous over and the number of wickets in the current over. It is important to note that there is a gap in data for 0.5 average wickets in previous over to 0.8. Thus, it is difficult to say if from 0.5 to 0.8 the trend is still positive and linear.

\newpage

# Model

The goal of the model is accurately predict when a wicket will occur in an [@ipl] game based on relevant variables from the dataset. Furtherore, I wanted to create a model that would achieve the most accuracy with the least amount of variables. To achieve this, three different generalized binomial family linear models (logistic regression) were used. The first model only had one input variable, the second one had two input variables, and third had four input variables. All models had the wicket boolean variable as the response variable.

## Model Set-up

All models are set up using the `glm` [@citeR] CRAN package. It uses the binomial family. All models trained on a training dataset, which contains 80% of the original data, which the other 20% being the testing set.

### Single Variable Generalized Linear Model

The single variable model uses a GLM model with only the over number as the input variable.

$\Pr(\text{Wicket} = 1) = \text{logit}^{-1}\left(\beta_0 + \beta_1 \cdot \text{over}\right)$

Beta Explanation:

$\beta_0$: Represents the general intercept, which represents the log-odds of a wicket occurring when the over variables does not matter

$\beta_1$: Represents the coefficient for the current over number


```{r}
#| label: tbl-model-summary-one-var
#| tbl-cap: "Logistic Regression Model Ouput for Wicket Prediction Using Only the Over"
#| echo: false
#| warning: false
simple_glm_wicket_model <- readRDS(here("models/simple_glm_wicket_model.rds"))

#summary(simple_glm_wicket_model)
modelsummary(list("Wicket Prediction (Single Variable Input)" = simple_glm_wicket_model))
```
Based on @tbl-model-summary-one-var, modeling with only the over variable accounts 0.22 RSME variability. Also for an increase in one over, the log odds of a wicket occuring increase by 0.058213 with a be value that is almost zero (less than $2*10^-16$). In terms of deviance, while not shown in the table, residual deviance of the model is roughly 300 degrees of freedom less than the null. The null deviance is 20849 on 51586 degrees of freedom while the residual deviance is 20586 on 51585 degrees of freedom.

### Model Set-Up for Two Variable Variable Generalized Linear Model

The single variable model uses a GLM model with the over number and number of wickets before an out as the input variable.

$\Pr(\text{Wicket} = 1) = \text{logit}^{-1}\left(\beta_0 + \beta_1 \cdot \text{over} + \beta_2 \cdot \text{previousOverWickets}\right)$

$\beta_0$: Represents the general intercept, which is the value that occurs when all other variables cancel each other out

$\beta_1$: Represents the coefficient for the current over number

$\beta_2$: Represents the coefficient for the number of wickets in the previous over

```{r}
#| label: tbl-model-summary-two-var
#| tbl-cap: "Logistic Regression Model Ouput for Wicket Prediction Using Over and Previous Wicket"
#| echo: false
#| warning: false

complex_glm_wicket_model <- readRDS(here("models/complex_glm_wicket_model.rds"))
#summary(complex_glm_wicket_model)
modelsummary(list("Wicket Prediction (Two Variable Input)" = complex_glm_wicket_model))
```
Based on @tbl-model-summary-two-var, modeling with only the over variable accounts 0.22 RSME variability. Also for an increase in number previous wickets in the previous over, the log odds of a wicket occurring increase by 1.852 with a p value that is almost zero (less than $2*10^-16$). The null deviance is 20849 on 51586 degrees of freedom while the residual deviance is 16584 on 51584 degrees of freedom. The logs odds increase for over is 0.005 with a p value of 0.168.

### Model Set-Up for Four Variable Generalized Linear Model

Adding the two extra variables, batting style and bowling style, to the model did not change the effectiveness in predictability at all. More rigorous analysis available in @sec-fourvar-model.

## Model justification

Based on @fig-over-wickets, there was a strong positive linear relationship between the over and the number of wickets taken, suggesting that the over can be a predictor of a wicket occurring. From @fig-bowlingstyle-wickets certain match-up produced a higher chance of a wicket occurring, such as left hand fast on a left hand batter, which is why both variables were added to the four variable model in @sec-fourvar-model. Finally from @fig-prevoverwickets-wickets, the average number of wickets that occurred in the previous over had a strong positive linear relationship with the number of wickets that occurred in balls in the next over, implying that previous over wickets impact the wicket probability of a ball in the next over.

# Results

## One Variable Model


```{r}
#| label: fig-onevarmodel-results
#| fig-cap: Linear Corrleation Between Wicket Probability and the Over
#| echo: false
#| warning: false

simple_glm_wicket_model_predictions <-
  predictions(simple_glm_wicket_model) |>
  as_tibble()

simple_glm_wicket_model_predictions |>
  mutate(wicket = factor(wicket)) |>
  ggplot(aes(x = over, y = estimate, color = wicket)) +
  stat_ecdf(geom = "point", alpha = 0.75) +
  labs(
    x = "The Over",
    y = "Estimated Probability that a wicket will occur",
    color = "Was actually a wicket"
  ) +
  theme_classic() +
  theme(legend.position = "bottom")
```
Based on @fig-onevarmodel-results, there's a strong linear positive relationship between the over number and the single variable model wicket prediction probability. Also, in the 20th over, the model will almost always predict a wicket.

```{r}
#| label: tbl-model-one-var-results
#| tbl-cap: "One Variable Model Underfits the Test Data"
#| echo: false
#| warning: false
test_data_simple <- test_data
predictions <- predict(simple_glm_wicket_model, newdata = test_data_simple, type = "response")

test_data_simple$predicted_wicket_prob <- predictions
test_data_simple <- test_data_simple %>% 
  mutate(predicted_wicket = predicted_wicket_prob >= 0.5) %>% 
  mutate(correct_prediction = predicted_wicket == wicket)

summary_results <- test_data_simple %>% group_by(wicket) %>% 
  summarise(
  correct = sum(correct_prediction),
  incorrect = sum(!correct_prediction)
) %>% mutate(wicket = if_else(wicket, "Yes", "No"))

summary_results %>% kable(col.names = c("Was Actually A Wicket?", "Correct", "Incorrect"))

```
From @tbl-model-one-var-results, the model has is 95.000% accurate, with a 100% accuracy for correctly predicting a wicket. However, the model has 0% change of correctly predicting when a wicket will occur. For this model, it is assumed that when the estimated probability of a wicket occurring is greater than or equal to 50%, the model is predicting a wicket.


## Two Variable Model

```{r}
#| label: fig-twovarmodel-results
#| fig-cap: Logarithmic Relationship Between Wicket Probability and the previous overs wickets
#| echo: false
#| warning: false
complex_glm_wicket_model_predictions <-
  predictions(complex_glm_wicket_model) |>
  as_tibble()

complex_glm_wicket_model_predictions |>
  mutate(wicket = factor(wicket)) |>
  ggplot(aes(x = prev_over_wickets, y = estimate, color = wicket)) +
  stat_ecdf(geom = "point", alpha = 0.75) +
  labs(
    x = "The Number of Wickets Taken in the Previous Over",
    y = "Estimated Probability that a wicket will occur",
    color = "Was actually a wicket"
  ) +
  theme_classic() +
  theme(legend.position = "bottom")
```
Based on @fig-twovarmodel-results, the number of wickets in the previous over had a positive log-like relationship with the estimated probability of a wicket occurring the two variable model. Also, when the previous over had two or more wickets, the model predicts 90% or more chance of a wicket occurring. It is important to note that this model also factors in variation from the current over of the game when generating predictions probability estimates.


```{r}
#| label: tbl-model-two-var-results
#| tbl-cap: "Two Variable Model Struggles to Predict Wickets in Test Data"
#| echo: false
#| warning: false
test_data_complex <- test_data
predictions <- predict(complex_glm_wicket_model, newdata = test_data_complex, type = "response")

test_data_complex$predicted_wicket_prob <- predictions
test_data_complex <- test_data_complex %>% 
  mutate(predicted_wicket = predicted_wicket_prob >= 0.5) %>% 
  mutate(correct_prediction = predicted_wicket == wicket)

summary_results <- test_data_complex %>% group_by(wicket) %>% 
  summarise(
  correct = sum(correct_prediction),
  incorrect = sum(!correct_prediction)
) %>% mutate(wicket = if_else(wicket, "Yes", "No"))

summary_results %>% kable(col.names = c("Was Actually A Wicket?", "Correct", "Incorrect"))
```
Via @tbl-model-two-var-results, the two variable model has a 94.952% accuracy on the test data. Wicket occurrences are predicted with a 2.640% accuracy and a wicket not occurring is predicted with a 99.804% accuracy. For this model, it is assumed that when the estimated probability of a wicket occurring is greater than or equal to 50%, the model is predicting a wicket.


## Four Variable Model

The four variable model is discussed in the results section since most of the variables did not have a large impact on the model. More information on that model in @sec-fourvar-model.


# Discussion

## Variables that Lead to Wickets 

## Variables that Do Not Lead to Wickets 

## Model Discussion

## Next Steps, Weaknesses, and Limitations

\newpage

\appendix

# Appendix {-}

## Four Variable Model {#sec-fourvar-model}

The model is set up using the `glm` [@citeR] CRAN package. It uses binomial family with the specified formula.

$\Pr(\text{Wicket} = 1) = \text{logit}^{-1}\left(\beta_0 + \beta_1 \cdot \text{over} + \beta_2 \cdot \text{previousOverWickets} + \beta_3 \cdot \text{BowlingStyle} + \beta_4 \cdot \text{BattingStyle}\right)$


$\beta_0$: Represents the general intercept, which is the value that occurs when all other variables cancel each other out.

$\beta_1$: Represents the coefficient for the current over number

$\beta_2$: Represents the coefficient for the number of wickets in the previous over

$\beta_3$: Represents the coefficient for the bowling style. Each bowling style has its own coefficient.

$\beta_4$: Represents the coefficient for the batting style (left handed or right handed). Each batting style has its own coefficient.

\newpage



```{r}
#| label: tbl-model-summary-four-var
#| tbl-cap: "Batting Style vs Bowling Style Do Not Heavily Impact Wicket Potential"
#| echo: false
#| warning: false
overly_complex_glm_wicket_model <- readRDS(here("models/overly_complex_glm_wicket_model.rds"))
#summary(overly_complex_glm_wicket_model)
modelsummary(overly_complex_glm_wicket_model)
```
Based on @tbl-model-summary-four-var, none of the batting styles or bowling style coefficient are statistically significant all with p values greater than 10%. This implies that most likely these variables not great predictors of wicket creation. The number of wickets in the previous over still has a statistically significant impact and has an increase of 0.031446 log odds per an increase of one wicket in the previous over. The residual deviance is 16574 on 51571 degrees of freedom compared to the null of 20849 on 51586 degrees of freedom.

## Variables Not Part of Model

```{r}
#| label: fig-stadium-wickets
#| fig-cap: Some stadiums are more prone to wickets than others.
#| echo: false
#| warning: false

stadium_boundaries <- cleaned_data %>%
  group_by(venue) %>%
  summarise(
    num_matches = n_distinct(match_id),
    num_wickets = sum(wicket == TRUE),  
  ) %>% arrange(desc(num_wickets), desc(num_matches))

ggplot(stadium_boundaries, aes(x = venue, y = (num_wickets/num_matches))) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(
       x = "Stadium Name",
       y = "Wickets Per Match") +
  theme_minimal() +
  coord_flip()

```
```{r}
#| label: fig-runrate-numofwickets
#| fig-cap: Current Run Rate Does Not Impact Wicket Rate
#| echo: false
#| warning: false

ggplot(cleaned_data, aes(x = run_rate, fill = factor(wicket))) +
  geom_histogram(position = "identity", alpha = 0.8, bins = 30) +
  labs(
    x = "Run Rate",
    y = "Number of Wickets",
  ) +
  scale_fill_discrete(name = "Wicket Occurred", labels = c("No Wicket", "Wicket")) + 
  theme_minimal()
```

\newpage

## Cleaned Data Dictionary {#sec-cleaned-data-dictionary}

Below are all of the variables in the cleaned data with an explanation of each variable, examples, and the data type.

Match id (Integer)  
Example: 335982  
A randomly generated ID uniquely identifies each cricket match in the data set.

Year (Integer)  
Example: 2022  
The year the match was played in.

Venue (string)  
Example: M Chinnaswamy Stadium  
The location the match is played in.

Innings (Integer)  
Example: 1  
The innings the current ball is played in. Should only be either 1 or two.

Over (Integer)  
Example: 7  
The over the current ball is played in. This should be from 1 to 20 in T20 Cricket.

Ball (Integer)  
Example: 3  
The current ball number in the over. This typically should be from 1 to 6, but could be more if no balls or wides are given.

Batting Team (String)  
Example: Kings XI Punjab  
The team that is currently batting.

Bowling Team (String)  
Example: Mumbai Indians  
The team that is currently bowling.

Striker (String)  
Example: AJ Finch  
The player that is currently on the wicket the bowler is bowling to.  
Bowler (String)  
Example: SMSM Senanayake  
The player that is bowling.

Runs off of the bat (Integer)  
Example: 3  
The number of the runs the team scored from this ball directly off of the striker's bat.

Wicket Lost Yet (Boolean)  
Example: True  
Did a wicket occur in this ball.  
Wickets Lost (Integer)  
Example: 7  
The number of wickets that have fallen. From 0 to 10\.

Target (Integer)  
Example: 207  
The par course for the given venue’s pitch on that match’s day.

Run Rate (Float)  
Example: 6.50  
The current run of the batting team in the match. This is the number of runs the team scores per over.

Batting Style (String)  
Example: Left hand Bat  
The batting style of a player. This is either left hand or right hand.

Bowling Style (String)  
Example: Slow Left arm Orthodox  
The bowling style of a player. This only exists if a player is a bowler.

Batting Player Role (String)  
Example: Allrounder  
The role of a batting player on the team.

Bowling Player Role (String)  
Example: Bowler  
The role of a bowling player on the team.

Previous Over Wickets (Number)  
Example: 2  
The number of wickets the bowling team had in the previous over.



## Idealized Methodology

This section will go over a comprehensive plan that could be used to translate real time cricket plays to actual data sets and databases that can be accessed by individuals interested in performing statistical analysis. Since this data is not a survey and is not really sampling based, there will be no mention of terms like stratified or cluster sampling or selection and response bias. This example will only be about the [@ipl] level cricket since this paper is only about the [@ipl]. However, most of this methodology can be used in other cricket leagues and other formats.

### Translating Plays to Data

The process of converting live cricket plays into structured data begins with real-time observation and documentation. During an Indian Premier League (IPL) match, a dedicated data entry team should closely monitor every moment of the game, capturing critical information about each play as it unfolds. A primary data collector focuses on immediate, live-capturable elements such as the bowler's name, the batsman on strike, the non-striking batsman, the type of bowling delivery, number of runs scored, and any fielding actions. This real-time data collection requires trained personnel with a deep understanding of cricket's nuanced rules and scoring mechanisms.

Simultaneously, a secondary team prepares for post-match data verification and enrichment. After the live match, this team reviews video recordings, carefully cross-referencing the initial data entries to correct any potential errors or omissions. This post-match review allows for more precise data collection, particularly for complex plays that might have been challenging to capture in real-time. The verification process involves multiple checks, including reviewing ball-tracking technologies, replay footage, and official match scorecards to ensure absolute accuracy.

The data entry process is designed with multiple layers of validation. Trained data entry specialists use specialized software that provides immediate validation checks, flagging potential inconsistencies or unusual entries for immediate review. This approach minimizes human error and ensures the highest possible data integrity. The entire process is structured to capture not just the basic outcomes of plays, but the rich contextual information that makes cricket data valuable for deeper statistical analysis.

### Making Data Easy to Use

To make this data easy to use, the team should create a clean structured or SQL database. Creating a robust and user-friendly database requires careful architectural planning. The proposed database design incorporates multiple interconnected tables that provide a comprehensive view of IPL cricket data. A player table serves as a central repository, with each player assigned a unique identifier that can be referenced across other tables. This player's primary key ID becomes a critical link in tables such as play, match, and season tables, enabling complex queries and data relationships.

The database design prioritizes data reliability and efficiency. By using multiple tables, the system eliminates redundancy and minimizes storage requirements. For instance, a match table would contain high-level match information, while a play table would capture granular, play-by-play details. A season table allows for broader and simple analysis, tracking changes and trends, winners, top scorers and more, across different IPL seasons. This structured approach not only improves data storage efficiency but also enhances the usability of the data set for researchers, analysts, and cricket enthusiasts.

### Making Data Accessible

Data accessibility is fundamental to the value of this cricket data set. The proposed system implements a controlled access mechanism through a carefully designed API that allows broad yet secure data retrieval. An API key system ensures that access is regulated, preventing potential system overloads while maintaining open accessibility. Rate limiting mechanisms are strategically implemented to protect the system from potential denial-of-service attacks, ensuring consistent data availability for all authorized users.

The public API is deliberately designed as a read-only interface, preventing unauthorized modifications to the core data set. This approach maintains data integrity while still providing transparent access to researchers, analysts, and cricket enthusiasts. By making the data publicly accessible through a controlled API, the system inherently supports data validation. Multiple users can cross-reference and verify the data, creating a collaborative environment of data integrity and trust.

Overall, this methodology represents a comprehensive approach to transforming live observational cricket plays into a structured, accessible, and reliable data set that can support advanced statistical analysis and deeper understanding of the Indian Premier League.

## Data Sheet for The Raw Data {#sec-data-sheet}

### Questions

#### Who put the data set together?

The raw data set was acquired from the [@cricketdata] R package. This data set had many contributors which can be seen through this [link](https://pkg.robjhyndman.com/cricketdata/), but the main developer is Rob Hyndman. The data set scraps the html from [@espncricinfo] and [@cricsheet]. These are two reputable organizations when it comes to cricket game data. [@cricsheet] is moreso responsible for play by play cricket data, like giving the data for what happens for every ball in a game, whereas [@espncricinfo] is more responsible for general player career information and statistics.

#### Who paid for the data set to be created?

The  [@cricketdata] R package is completely open source and free under the GPL-3 license. The source code can be seen through this [link](https://github.com/robjhyndman/cricketdata). In terms of ESPN Cricinfo, this is a site and organization that makes money talking about cricket and airing games. So, it is in their best interest to give basic statistics for free on their website to entice people to use their services to watch and interact with content related to cricket. Cricsheet is operated by Stephen Rushe. He has written code to extract play-by-play cricket match data, which most likely means he is web scraping. There is not much other information about the code that extracts the data and what sites he uses.

#### How complete is the data set?

The play by play data is very complete. For each ball in a game, it includes the bowler, batter, the batter on the opposite wicket, the venue, teams, the runs given, and more. The important data that seems to be missing is data related to the position of the fielders and the distance and final location of the ball once and if it hits the bat. In terms of player info, it is also very complete. It includes information about their batting style, blowing style if applicable, and their role on the team. The only issue here is that a player's role on the team can change depending on the team they are one. For instance, a player might be an opening batsman when playing in test cricket but could be a midover batsman when playing in T20. This data set does not account for this discrepancy. 

#### Which variables are present, and, equally, not present, for particular observations?

For play-by-play data the bowler, battsman, and teams involved in the play are present and so is general game information. Furthermore, the final outcome of the play, such as the number of runs, or if a wicket occurred are also given. Information about ball speed, distance, location, and fielding is not given. For player information, information about their country of citizenship, country of birth, batting style, bowling style, and batting order, and player role on a team are given. Potential missing observations with the player information are listed in @sec-complete-data set.

### Data Dictionary For Raw Data {#sec-data-dictionary}

For this report, there are only two data sets used, the IPL (Indian Premier League) play-by-play data and player metadata. The variables for these data sets will be listed here with examples.

#### Play-by-play IPL Data

Match id (Integer)  
Example: 335982  
A randomly generated ID uniquely identifies each cricket match in the data set.

Season (String)  
Example: 2007/8 or 2024  
Represents the IPL tournament year of the match. For instance “2007/8” represents the 2007 to 2008 IPL season and 2024 represents the tournament that was played only in 2024.

Season (Date)  
Example: 2024-04-15  
Represents the day the match was played. It is in a year-month-day format.

Venue (String)  
Example: M Chinnaswamy Stadium  
The location the match is played in.

Innings (Integer)  
Example: 1  
The innings the current ball is played in. Should only be either 1 or two.

Over (Integer)  
Example: 7  
The over the current ball is played in. This should be from 1 to 20 in T20 Cricket.

Ball (Integer)  
Example: 3  
The current ball number in the over. This typically should be from 1 to 6, but could be more if no balls or wides are given.

Batting Team (String)  
Example: Kings XI Punjab  
The team that is currently batting.

Bowling Team (String)  
Example: Mumbai Indians  
The team that is currently bowling.

Striker (String)  
Example: AJ Finch  
The player that is currently on the wicket the bowler is bowling to.

Non-Striker (String)  
Example: A Ashish Reddy  
The player that is batting but is on the opposition wicket.

Bowler (String)  
Example: SMSM Senanayake  
The player that is bowling.

Runs off of the bat (Integer)  
Example: 3  
The number of the runs the team scored from this ball directly off of the strikers bat.

Extra Runs (Integer)  
Example: 1  
The number of runs that the team scored that was not because of the striker's bat. This could be because of wides.

Extra Ball (Boolean)  
Example: False  
Was this ball an extra ball? For instance, this ball could be extra due to a wide.

Balls Remaining (Integer)  
Example: 79  
The number of balls remaining in the game. This is from 0 to 120\.

Runs Scored (Integer)  
Example: 101  
The number of runs already scored by the batting team.

Wicket (Boolean)  
Example: True  
Did a wicket occur in this ball.  
Wickets Lost (Integer)  
Example: 7  
The number of wickets that have fallen. From 0 to 10\.

First Innings Total (Integer)  
Example: 165  
The total number of runs earned in the first innings.

Second Innings Total (Integer)  
Example: 168  
The total number of runs earned in the second innings.

Target (Integer)  
Example: 207  
The par course for the given venue’s pitch on that match’s day.

Wides (Integer)  
Example: 4  
The number of wides bowled in this over.

No Balls (Integer)  
Example: 2  
The number of no balls bowled in this over.

Byes (Integer)  
Example: 4  
Runs scored by byes in this ball. This ranges from 0 to 4\.

Leg Byes (Integer)  
Example: 2  
Runs scored by leg byes in this ball. This ranges from 0-4.

Wicket Type (String)  
Example: Bowled  
If a wicket occurred, this column will describe how it happened. It includes bowled, stumped, and caught.

Player Dismissed (String)  
Example: A Ashish Reddy  
If a wicket occurred, this column will have the name of the player that was dismissed.

#### Player Metadata

Cricinfo Player id (Integer)  
Example: 1175501  
A randomly generated ID uniquely identifies each cricket player from Cricinfo data.

Cricsheet Player id (Alphanumeric)  
Example: 21d38d47  
A randomly generated ID uniquely identifies each cricket player from Cricinfo data.

Unique Name (String)  
Example: Alkandari Abdulrahman  
The unique name of the player that is stored in the [@cricketdata] package. All other tables will only use the unique name of a player and not the full name of the player.

Full Name (String)  
Example: AGHM Alkandari Abdulrahman  
The full name of a player.

Country (String)  
Example: Zimbabwe  
The country of citizenship for this player.

Date of Birth (Date)  
Example: 1971-09-21  
The day the player was born in a year-month-day format.

Birthplace (String)  
Example: Nangrahar, Afghanistan  
The city and sometimes country a player was born in.

Batting Style (String)  
Example: Left hand Bat  
The batting style of a player. This is either left hand or right hand.

Bowling Style (String)  
Example: Slow Left arm Orthodox  
The bowling style of a player. This only exists if a player is a bowler.

Player Role (String)  
Example: Allrounder  
The role of a player on the team.

\newpage

# References

